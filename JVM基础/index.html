<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JVM基础, Mr-lee">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JVM基础 | Mr-lee</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Mr-lee</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>主页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>时光轴</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于我</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Mr-lee</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			主页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			时光轴
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于我
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Mr-lee-MQ/Mr-lee-MQ.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #F062A7;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Mr-lee-MQ/Mr-lee-MQ.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/23.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JVM基础</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
        background-color: rgb(255, 255, 255,0.7);
        border-radius: 10px;
        box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java%E8%BF%9B%E9%98%B6/">
                                <span class="chip bg-color">Java进阶</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%90%8E%E7%AB%AF/" class="post-category">
                                后端
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-03-08
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-10-10
                </div>
                

                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="JVM基础"><a href="#JVM基础" class="headerlink" title="JVM基础 "></a>JVM基础 <a id="more"></a></h1><h1 id="1、类的加载器和类加载过程"><a href="#1、类的加载器和类加载过程" class="headerlink" title="1、类的加载器和类加载过程"></a>1、类的加载器和类加载过程</h1><img src="/JVM%E5%9F%BA%E7%A1%80/kuangstudydfe58db2-ee75-464b-803f-6c36ca896938.png" class>

<ul>
<li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li>
<li>ClassLoader是负责Class文件的加载，至于它是否可以运行，则由Execution Engine决定</li>
<li>加载的类信息，<strong>存放于一块称为方法区的内存空间</strong>，除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li>
</ul>
<h2 id="1-1、类加载器ClassLoader角色"><a href="#1-1、类加载器ClassLoader角色" class="headerlink" title="1.1、类加载器ClassLoader角色"></a>1.1、类加载器ClassLoader角色</h2><img src="/JVM%E5%9F%BA%E7%A1%80/kuangstudy7de4ff2d-a01d-493d-ac60-c806184a9584.png" class>

<ol>
<li>class file存放在本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM中来根据这个文件实例化个一模一样的实例。</li>
<li>class file加载到JVM中，被称为DNA元数据模板，放在方法区</li>
<li>在.class文件-&gt; JVM-&gt; 最终成为元数据模板，这个过程需要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。</li>
</ol>
<h2 id="1-2、类的加载过程"><a href="#1-2、类的加载过程" class="headerlink" title="1.2、类的加载过程"></a>1.2、类的加载过程</h2><img src="/JVM%E5%9F%BA%E7%A1%80/kuangstudy7cae202d-8776-4a6e-9a07-01c898474869.png" class>

<ol>
<li>加载：<ul>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
<li>加载.class文件的方式有<ul>
<li>本地系统</li>
<li>jar包</li>
<li>运行时计算生成，使用最多的是：动态代理</li>
<li>其他文件生成：jsp</li>
<li>……</li>
</ul>
</li>
</ul>
</li>
<li>链接（Linking)：<ul>
<li>验证：<ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证（CA FE BA BE）</li>
</ul>
</li>
<li>准备：<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值</li>
<li><strong>这里不包含用final修饰的static，因为final在编译的时候就会分配，准备阶段会显式初始化</strong></li>
<li>不会为实力变量分配初始化，类变量会分配在方法区中，而<strong>实例变量是会随着对象一起分配到Java堆中</strong>。</li>
</ul>
</li>
<li>解析：<ul>
<li>将常量池内的符号引用转换为直接引用的过程。</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</li>
<li>符号引用就是一组符号来描述所引用的目标，符号引用的字面量形式明确定义在Class文件格式中。直接引用就是<strong>直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄</strong></li>
<li>解析动作主要针对<strong>类或接口，字段，类方法，接口方法，方法类型</strong>等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info，CONSTANT_Methodref_info等。</li>
</ul>
</li>
</ul>
</li>
<li>初始化：<ul>
<li>初始化阶段就是执行<strong>类构造器</strong>方法<clinit>()的过程</clinit></li>
<li>此方法不需要定义，是javac编译器自动收集类中的所有<strong>类变量的赋值动作和静态代码块中的语句合并而来。</strong>（无静态变量和静态方法，静态代码块等就不会执行<clinit>()）</clinit></li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行。</li>
<li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<init>()）</init></li>
<li>若该类有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕</clinit></clinit></li>
<li>虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁(保证只加载一次)</clinit></li>
</ul>
</li>
</ol>
<h2 id="1-3、类加载器的分类"><a href="#1-3、类加载器的分类" class="headerlink" title="1.3、类加载器的分类"></a>1.3、类加载器的分类</h2><ul>
<li>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li>
<li>从概念上来讲，自定义类加载器一般指的是程序中有开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。</li>
<li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：<img src="/JVM%E5%9F%BA%E7%A1%80/kuangstudy9957b99b-9565-4adc-af49-5e4d145e56d9.png" class>
这里四者的关系是包含关系，不是上下级关系，也不是父子继承关系。</li>
</ul>
<h3 id="1-3-1、虚拟机自带的加载器"><a href="#1-3-1、虚拟机自带的加载器" class="headerlink" title="1.3.1、虚拟机自带的加载器"></a>1.3.1、虚拟机自带的加载器</h3><ul>
<li>启动类加载器（引导类加载器，Bootstrap classLoader)<ul>
<li>这个类加载使用c/C++语言实现的，嵌套在JVM内部。</li>
<li>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun. boot.class.path路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承自<code>java.lang.classLoader</code>，没有父加载器。加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为<code>java、javax、sun</code>等开头的类</li>
</ul>
</li>
</ul>
<h3 id="1-3-2、用户自定义的类加载器"><a href="#1-3-2、用户自定义的类加载器" class="headerlink" title="1.3.2、用户自定义的类加载器"></a>1.3.2、用户自定义的类加载器</h3><ul>
<li>为什么要自定义类加载器?<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄漏</li>
</ul>
</li>
<li>用户自定义类加载器实现步骤：<ul>
<li>开发人员可以通过继承抽象类<code>java.lang.classLoader</code>类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会去继承classLoader类并重写<code>loadclass()</code>方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖<code>loadclass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findclass()</code>方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承<code>URLClassLoader</code>类，这样就可以避免自己去编写<code>findclass()</code>方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>
</ul>
</li>
</ul>
<h3 id="1-3-3、获取ClassLoader的途径"><a href="#1-3-3、获取ClassLoader的途径" class="headerlink" title="1.3.3、获取ClassLoader的途径"></a>1.3.3、获取ClassLoader的途径</h3><ul>
<li>方式一：获取当前类的ClassLoader<br><code>class.getClassLoader()</code></li>
<li>方式二：获取当前线程上下文的ClassLoader<br><code>Thread。currentThread().getContextClassLoader()</code></li>
<li>方式三：获取系统的ClassLoader<br><code>ClassLoader.getSystemClassLoader()</code></li>
<li>方式四：获取调用者的ClassLoader<br><code>DriverManager.getCallerClassLoader()</code></li>
</ul>
<h2 id="1-4、双亲委派机制"><a href="#1-4、双亲委派机制" class="headerlink" title="1.4、双亲委派机制"></a>1.4、双亲委派机制</h2><img src="/JVM%E5%9F%BA%E7%A1%80/kuangstudy0204b515-c4e8-4812-8aca-35068f50d6de.png" class>
<p><strong>工作原理</strong></p>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行;</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归,请求最终将到达顶层的启动类加载器;</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ol>
<img src="/JVM%E5%9F%BA%E7%A1%80/kuangstudy5445fd63-48ac-4e1c-950d-c92ceb419dd7.png" class>
<p><strong>优势</strong></p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改<ul>
<li>自定义类: java.lang.string</li>
<li>自定义类: java.lang.shkstart</li>
<li>抛出异常<code>java.lang.securityException: Prohibited package name: java.lang</code></li>
</ul>
</li>
</ul>
<h2 id="1-5、沙箱安全机制"><a href="#1-5、沙箱安全机制" class="headerlink" title="1.5、沙箱安全机制"></a>1.5、沙箱安全机制</h2><p>自定义String类，但是在加载自定义string类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中<code>java\lang\String.class</code>)，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p>
<p>在JVM中表示两个class对象是否为同一个类存在<strong>两个必要条件</strong>:</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的classLoader(指classLoader实例对象)必须相同。</li>
</ul>
<p>换句话说，在JVM中，即使这两个类对象(class对象)来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的classLoader实例对象不同，那么这两个类对象也是不相等的。</p>
<h2 id="1-6、对类加载器的引用"><a href="#1-6、对类加载器的引用" class="headerlink" title="1.6、对类加载器的引用"></a>1.6、对类加载器的引用</h2><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个<strong>引用作为类型信息</strong>的一部分保存在<strong>方法区</strong>中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<h2 id="1-7、类的主动使用和被动使用"><a href="#1-7、类的主动使用和被动使用" class="headerlink" title="1.7、类的主动使用和被动使用"></a>1.7、类的主动使用和被动使用</h2><p>Java程序对类的使用方式分为:主动使用和被动使用。<br><strong>主动使用</strong>，又分为七种情况:</p>
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（比如: <code>Class.forName(&quot;com.atguigu.Test&quot;)</code>)</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK 7开始提供的动态语言支持:<ul>
<li><code>java.lang.invoke.MethodHandle</code>实例的解析结果</li>
<li><code>REF_getstatic</code>、<code>REF_putstatic</code>、<code>REF_invokestatic</code>句柄对应的类没有初始化，则初始化</li>
</ul>
</li>
</ul>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对<strong>类的被动使用</strong>，都<strong>不会导致类的初始化</strong>。</p>
<h1 id="2、运行时数据区概述及线程"><a href="#2、运行时数据区概述及线程" class="headerlink" title="2、运行时数据区概述及线程"></a>2、运行时数据区概述及线程</h1><h2 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h2><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>


<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应.的数据区域会随着线程开始和结束而创建和销毁。</p>
<p>➢每个线程：独立包括程序计数器、栈、本地栈。<br>➢线程间共享：堆、堆外内存(永久代或元空间、代码缓存)</p>
<h1 id="3、线程"><a href="#3、线程" class="headerlink" title="3、线程"></a>3、线程</h1><ul>
<li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</li>
<li>在Hotspot JVM里， 每个线程都与操作系统的本地线程直接映射。</li>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</li>
</ul>
<h2 id="3-1、JVM系统线程"><a href="#3-1、JVM系统线程" class="headerlink" title="3.1、JVM系统线程"></a>3.1、JVM系统线程</h2><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main (String[])的main线程以及所有这个main线程自己创建的线程。</p>
<p>这些主要的后台系统线程在Hotspot JVM里 主要是以下几个:</p>
<ul>
<li><strong>虚拟机线程</strong>:这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li>
<li><strong>周期任务线程</strong>:这种线程是时间周期事件的体现(比如中断)，他们一般用于周期性操作的调度执行。</li>
<li><strong>GC线程</strong>:这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>
<li><strong>编译线程</strong>:这种线程在运行时会将字节码编译成到本地代码。</li>
<li><strong>信号调度线程</strong>:这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li>
</ul>
<h1 id="4、程序计数器介绍"><a href="#4、程序计数器介绍" class="headerlink" title="4、程序计数器介绍"></a>4、程序计数器介绍</h1>

<p>JVM中的程序计数寄存器(Program Counter Register) 中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。这里并非是广义上所指的物理寄存器，或许将其翻译为PC计数器(或指令计数器)会更加贴切(也称为程序钩子)，并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>
<ul>
<li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li>
<li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址;或者, 如果是在执行native方法，则是未指定值(undefined)。</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li>
<li>它是唯一一个在Java虚拟机规范中<strong>没有规定任何OutOtMemoryError</strong>情况的区域。</li>
</ul>
<h2 id="4-1、作用"><a href="#4-1、作用" class="headerlink" title="4.1、作用"></a>4.1、作用</h2>

<p>PC寄存器用来<strong>存储指向下一条指令的地址</strong>，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<h2 id="4-2、常见面试题"><a href="#4-2、常见面试题" class="headerlink" title="4.2、常见面试题"></a>4.2、常见面试题</h2><p><strong>使用PC寄存器存储字节码指令地址有什么用呢?<br>为什么使用PC寄存器记录当前线程的执行地址呢？</strong><br>答：因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><strong>PC寄存器为什么设定为线程私有</strong></p>
<p>答：我们都知道所谓的多线程在-一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢?<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样-来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢?每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
<h1 id="5、虚拟机栈概述"><a href="#5、虚拟机栈概述" class="headerlink" title="5、虚拟机栈概述"></a>5、虚拟机栈概述</h1><h2 id="5-1、虚拟机出现的背景"><a href="#5-1、虚拟机出现的背景" class="headerlink" title="5.1、虚拟机出现的背景"></a>5.1、虚拟机出现的背景</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。<br>优点：跨平台，指令集小，编译器容易实现<br>缺点：性能下降，实现同样的功能需要更多的指令。</p>
<h2 id="5-2、基本内容"><a href="#5-2、基本内容" class="headerlink" title="5.2、基本内容"></a>5.2、基本内容</h2><ul>
<li>Java虚拟机栈是什么?<ul>
<li>Java虚拟机栈(Java Virtual Machine Stack) ，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame) ，对应着一次次的Java方法调用。</li>
<li>是线程私有的</li>
</ul>
</li>
<li>生命周期：<ul>
<li>生命周期和线程一致。</li>
</ul>
</li>
<li>作用：<ul>
<li>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>对于栈来说不存在垃圾回收问题，存在OOM</li>
</ul>
<p>JVM直接对Java栈的操作只有两个:</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//每个方法执行，伴随着进栈(入栈、压栈)- 执行结束后的出栈工作</span></code></pre>
<h2 id="5-3、栈中可能出现的异常"><a href="#5-3、栈中可能出现的异常" class="headerlink" title="5.3、栈中可能出现的异常"></a>5.3、栈中可能出现的异常</h2><p>Java虚拟机规范允许<strong>Java栈的大小是动态的或者是固定不变的</strong>。</p>
<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<code>StackOverflowError</code> 异常。</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个<code>OutOfMemoryError</code> 异常。</li>
</ul>
<h2 id="5-4、栈是运行时的单位，而堆是存储的单位。"><a href="#5-4、栈是运行时的单位，而堆是存储的单位。" class="headerlink" title="5.4、栈是运行时的单位，而堆是存储的单位。"></a>5.4、栈是运行时的单位，而堆是存储的单位。</h2><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。<br>堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</p>
<h2 id="5-5、设置虚拟机栈的大小"><a href="#5-5、设置虚拟机栈的大小" class="headerlink" title="5.5、设置虚拟机栈的大小"></a>5.5、设置虚拟机栈的大小</h2><p>-Xss256m</p>
<h2 id="5-6、栈的存储单位"><a href="#5-6、栈的存储单位" class="headerlink" title="5.6、栈的存储单位"></a>5.6、栈的存储单位</h2><h3 id="5-6-1、栈中存储什么？"><a href="#5-6-1、栈中存储什么？" class="headerlink" title="5.6.1、栈中存储什么？"></a>5.6.1、栈中存储什么？</h3><ol>
<li>每个线程都有自己的栈，栈中的数据都是<strong>以栈帧(stack Frame) 的格式存在</strong>。</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧(Stack Frame) 。</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ol>
<h3 id="5-6-2、栈运行原理"><a href="#5-6-2、栈运行原理" class="headerlink" title="5.6.2、栈运行原理"></a>5.6.2、栈运行原理</h3><ol>
<li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循“先进后出”/“后进先出”原则。</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(栈顶栈帧)是有效的，这个栈帧被称为<strong>当前栈帧</strong>(Current Frame) ，与当前栈帧相对应的方法就是<strong>当前方法</strong>(Current Method)，定义这个方法的类就是<strong>当前类</strong>(Current Class) 。</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li>
<li>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令;另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li>
</ol>
<h3 id="5-6-3、栈帧内部结构"><a href="#5-6-3、栈帧内部结构" class="headerlink" title="5.6.3、栈帧内部结构"></a>5.6.3、栈帧内部结构</h3><p>每个栈帧中存储着:</p>
<ol>
<li>局部变量表（Local variables)</li>
<li>操作数栈（operand stack）（或表达式栈）</li>
<li>动态链接(Dynamic Linking)（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）(或方法正常退出或者异常退出的定义)</li>
<li>一些附加信息{%asset_img kuangstudy16b950bc-5b44-4d45-8320-ef999866882f.png%}

</li>
</ol>
<h3 id="5-6-4、局部变量表"><a href="#5-6-4、局部变量表" class="headerlink" title="5.6.4、局部变量表"></a>5.6.4、局部变量表</h3><ol>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
<li>定义为<strong>一个数字数组</strong>，主要用于<strong>存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用(reference） ，以及returnAddress类型。</li>
<li>由于局部变量表是建立在线程的栈上，是线程的<strong>私有数据</strong>，因此<strong>不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是<strong>不会改变</strong>局部变量表的大小的。</li>
<li><strong>方法嵌套调用的次数由栈的大小决定</strong>。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
<li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</strong>。</li>
</ol>
<h3 id="5-6-5、Slot"><a href="#5-6-5、Slot" class="headerlink" title="5.6.5、Slot"></a>5.6.5、Slot</h3><ol>
<li><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p>
</li>
<li><p>局部变量表，最基本的存储单元是Slot (变量槽)</p>
</li>
<li><p>局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress 类型的变量。</p>
</li>
<li><p>在局部变量表里，32位以内的类型只占用一个slot (包括returnAddress类型)，64位的类型(long和double)占用两个slot。</p>
<ul>
<li>byte、short、char在存储前被转换为int, boolean也被转换为int，0表示false，非0表示true。</li>
<li>long和double则占据两个Slot。</li>
</ul>
</li>
<li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上</p>
</li>
<li><p>如果当前帧是由<strong>构造方法或者实例方法</strong>创建的，那么该<strong>对象引用this</strong>将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</p>
</li>
<li><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。(比如:访问long或double类型变量)</p>
</li>
<li><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<p><strong>补充</strong></p>
</li>
<li><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
</li>
<li><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
</li>
</ol>
<h2 id="5-7、操作数栈"><a href="#5-7、操作数栈" class="headerlink" title="5.7、操作数栈"></a>5.7、操作数栈</h2><ol>
<li>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的<strong>操作数栈</strong>，也可以称之为<strong>表达式栈</strong>(Expression Stack)。</li>
<li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push) /出栈(pop)。<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</li>
<li>比如:执行复制、交换、求和等操作</li>
</ul>
</li>
<li>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</li>
<li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在<strong>编译期就定义好了</strong>，保存在方法的Code属性中，为max_stack的值。</li>
<li>栈中的任何一个元素都是可以任意的Java数据类型。<ul>
<li>32bit的类型占用<strong>一个栈</strong>单位深度</li>
<li>64bit的类型占用<strong>两个栈</strong>单位深度</li>
</ul>
</li>
<li>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。</li>
<li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li>
<li>另外，我们说Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈。</li>
</ol>
<p><strong>问题</strong></p>
<p>i++ 和 ++i的区别？<br>i++ 先赋值再+1，++i 先+1再赋值</p>
<h3 id="5-7-1、栈顶缓存技术"><a href="#5-7-1、栈顶缓存技术" class="headerlink" title="5.7.1、栈顶缓存技术"></a>5.7.1、栈顶缓存技术</h3><p><strong>动态链接（指向运行时常量池的方法引用）</strong></p>
<ol>
<li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中<strong>该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够<strong>实现动态链接</strong>（Dynamic Linking） 。比如： invokedynamic指令</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></li>
</ol>
{%asset_img kuangstudyacdd449e-b6e1-4748-9cf5-9f1a27e8c054.png%}

<h3 id="5-7-2、方法的调用-解析与分派"><a href="#5-7-2、方法的调用-解析与分派" class="headerlink" title="5.7.2、方法的调用:解析与分派"></a>5.7.2、方法的调用:解析与分派</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。</p>
<ul>
<li>静态链接：<br>当一个字节码文件被装载进JVM内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li>
<li>动态链接：<br>如果被<strong>调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li>
</ul>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding） 。绑定是<strong>一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</strong></p>
<ul>
<li>早期绑定：<br>早期绑定就是指被调用的目标方法如果在<strong>编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
<li>晚期绑定：<br>如果被调用的方法在<strong>编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定</strong>相关的方法，这种绑定方式也就被称之为晚期绑定。</li>
</ul>
<h3 id="5-7-3、虚方法和非虚方法"><a href="#5-7-3、虚方法和非虚方法" class="headerlink" title="5.7.3、虚方法和非虚方法"></a>5.7.3、虚方法和非虚方法</h3><p>虚拟机中提供了以下几条方法调用指令：</p>
<ul>
<li>普通调用指令：<ol>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用<init>方法，私有及父类方法，解析阶段确定唯一方法版本</init></li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ol>
</li>
<li>动态调用指令：<ol>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ol>
</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。<strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法</strong>，<strong>其余的（final修饰的除外）称为虚方法。</strong></p>
<h3 id="5-7-4、虚方法表"><a href="#5-7-4、虚方法表" class="headerlink" title="5.7.4、虚方法表"></a>5.7.4、虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能， JVM采用在<strong>类的方法区建立一个虚方法表</strong>（virtual method table） （<strong>非虚方法不会出现在表中</strong>）来实现。使用<strong>索引表来代替查找</strong>。<br>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。<br>那么虚方法表什么时候被创建？<br>虚方法表会在<strong>类加载的链接阶段被创建并开始初始化</strong>，类的变量初始值准备完成之后， JVM会把该类的方法表也初始化完毕。</p>
<h3 id="5-7-5、方法返回地址"><a href="#5-7-5、方法返回地址" class="headerlink" title="5.7.5、方法返回地址"></a>5.7.5、方法返回地址</h3><ol>
<li>存放调用该方法的pc寄存器的值。</li>
<li>一个方法的结束，有两种方式:<br>➢正常执行完成<br>➢出现未处理的异常，非正常退出</li>
<li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>
</ol>
<p>当一个方法开始执行后，只有<strong>两种方式</strong>可以退出这个方法:</p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令(return)，会有返回值传递给，上层的方法调用者，简称正常完成出口;<br>➢一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要<strong>根据方法返回值的实际数据类型</strong>而定。<br>➢在字节码指令中，返回指令包含<strong>ireturn</strong> (当返回值是boolean、 byte、char.short和int类型时使用)、lreturn、 freturn、 dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接0的初始化方法使用。</li>
<li>在方法执行的过程中遇到了<strong>异常(Exception)</strong> ，并且这个异常<strong>没有在方法内进行处理</strong>，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。方法执行过程中抛出异常时的异常处理，存储在一个 异常处理表，方便在发生异常的时候找到处理异常的代码。{%asset_img kuangstudyf5ea3e3d-c56d-4344-b9e1-90b88068bc85.jpg%}

</li>
</ol>
<p><strong>一些附加信息</strong></p>
<p>栈帧中还允许携带与Java虛拟机实现相关的一些附加信息。例如 对程序调试提供支持的信息。</p>
<h2 id="5-8、-栈的相关面试题"><a href="#5-8、-栈的相关面试题" class="headerlink" title="5.8、 栈的相关面试题"></a>5.8、 栈的相关面试题</h2><ol>
<li>举例栈溢出的情况? (StackOverflowError)<br>通过-Xss设置栈的大小，如果申请不到内存时，内存溢出OOM</li>
<li>调整栈大小，就能保证不出现溢出吗?<br>不能</li>
<li>分配的栈内存越大越好吗?<br>不是，整个内存是有限的，可能会造成可用线程数减少</li>
<li>垃圾回收是否会涉及到虚拟机栈?<br>不会</li>
<li>方法中定义的局部变量是否线程安全?</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//s1的声明方式是线程安全的</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//StringBuilder:线程不安全</span>
    StringBuilder s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//sBuilder的操作过程:是线程不安全的</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span>StringBuilder sBuilder<span class="token punctuation">)</span><span class="token punctuation">{</span>
    sBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//s1的操作:是线程不安全的</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> StringBuilder <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    StringBuilder s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s1<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//s1的操作:是线程安全的</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    StringBuilder s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h1 id="6、什么是本地方法"><a href="#6、什么是本地方法" class="headerlink" title="6、什么是本地方法?"></a>6、什么是本地方法?</h1><p>简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是 这样- -一个Java方法:该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C” 告知C++编译器去调用一个C的函数。</p>
<p>“A native method is a Java method whose implementation isprovided by non-java code.”</p>
<p>在定义一个native method时，并不提供实现体(有些像定义一个Javainterface)，因为其实现体是由非java语言在外面实现的。本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p>


<h2 id="6-1、-为什么要使用"><a href="#6-1、-为什么要使用" class="headerlink" title="6.1、 为什么要使用"></a>6.1、 为什么要使用</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<p>与Java环境外交互:<br><strong>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因</strong>。你可以想想Java需要与一些底层 系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制: 它为我们提供了一个非常简洁的接口,而且我们无需去了解Java应用之外的繁琐的细节。</p>
<h1 id="7、本地方法栈"><a href="#7、本地方法栈" class="headerlink" title="7、本地方法栈"></a>7、本地方法栈</h1><ol>
<li>Java虚拟机栈用于管理Java方法的调用， 而本地方法栈用于管理本地方法的调用。</li>
<li>本地方法栈，也是线程私有的。</li>
<li>允许被实现成固定或者是可动态扩展的内存大小。 (在内存溢出方面是相同的)<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虛拟机将会抛出一个outofMemoryError 异常。</li>
</ul>
</li>
<li>本地方法是使用c语言实现的。</li>
<li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。</li>
</ol>
<h2 id="7-1、-堆的核心概述"><a href="#7-1、-堆的核心概述" class="headerlink" title="7. 1、 堆的核心概述"></a>7. 1、 堆的核心概述</h2><ul>
<li>一个JVM实例<strong>只存在一个堆内存</strong>，堆也是Java内存管理的核心区域。</li>
<li>Java 堆区在<strong>JVM启动的时候即被创建</strong>，其<strong>空间大小也就确定了</strong>。是JVM管理的最大一块内存空间。<ul>
<li>堆内存的大小是可以调节的。</li>
</ul>
</li>
<li>《Java虚拟机规范》规定，堆<strong>可以处于物理上不连续</strong>的内存空间中，但在<strong>逻辑上它应该被视为连续</strong>的。</li>
<li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer, TLAB) 。</li>
<li>《Java虛拟机规范》中对Java堆的描述是:所有的对象实例以及数组都应当在运行时分配在堆上。(The heap is the run-time data area from which memory for all cla3s instances and arrays is allocated )<ul>
<li>我要说的是: “几乎”所有的对象实例都在这里分配内存。一从实际使用角度看的。</li>
</ul>
</li>
<li><strong>数组和对象可能永远不会存储在栈上</strong>，因为<strong>栈帧中保存引用</strong>，这个<strong>引用指向对象或者数组在堆中的位置</strong>。</li>
<li>在方法结束后，堆中的对象<strong>不会马上被移除</strong>，仅仅在<strong>垃圾收集的时候才会被移除</strong>。</li>
<li>堆，是GC ( Garbage Collection， 垃圾收集器<strong>)执行垃圾回收的重点区域</strong>。</li>
</ul>


<h2 id="内存细分"><a href="#内存细分" class="headerlink" title="内存细分"></a>内存细分</h2><p>现代垃圾收集器大部分都基于分代收集理论设计,堆空间细分为:</p>
<ul>
<li><p><strong>Java 7</strong>及之前堆内存逻辑上分为三部分:新生区+老年区+<strong>永久区</strong></p>
<ul>
<li>Young Generation Space新生区<ul>
<li>Young/New又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space <strong>老年区</strong> Old/ Tenure</li>
<li>Permanent Space <strong>永久区</strong> Perm</li>
</ul>
</li>
<li><p><strong>Java 8</strong>及之后堆内存逻辑上分为三部分:新生区+老年区+<strong>元空间</strong></p>
<ul>
<li>Young Generation Space新生区<ul>
<li>Young/New又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space <strong>老年区</strong> Old/ Tenure</li>
<li>Meta Space <strong>元空间</strong> Meta</li>
</ul>
</li>
</ul>
<h2 id="7-2、-设置堆内存大小与OOM"><a href="#7-2、-设置堆内存大小与OOM" class="headerlink" title="7.2、 设置堆内存大小与OOM"></a>7.2、 设置堆内存大小与OOM</h2><p><strong>-XX:+PrintGCDetails</strong>：打印GC详情<br><strong>jps</strong>：查看java进程<br><strong>jstat -gc java进程号</strong>：查看内存使用情况</p>
<ul>
<li><p>Java堆区用于存 储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项” -Xmx”和”-xms”来进行设置。</p>
<ul>
<li><p>-Xms用来设置堆空间(年轻代+老年代)的</p>
<p>初始内存大小， 等价于-XX: InitialHeapSize</p>
<ul>
<li>-X是jvm的运行参数</li>
</ul>
</li>
</ul>
</li>
<li><p>ms是memory start</p>
<ul>
<li>-Xmx用来设置堆空间(年轻代+老年代)的<strong>最大</strong>内存大小， 等价于-XX: MaxHeapSize :</li>
</ul>
</li>
<li><p>一旦堆区中的内存大小<strong>超过“-Xmx”所指定的最大内存</strong>时，将会抛出OutOfMemoryError异常。</p>
</li>
<li><p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了<strong>能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p>
</li>
<li><p>默认情况下，初始内存大小:物理电脑内存大小/ 64 最大内存大小:物理电脑内存大小/ 4</p>
</li>
</ul>
<h2 id="7-3、-年轻代与老年代"><a href="#7-3、-年轻代与老年代" class="headerlink" title="7.3、 年轻代与老年代"></a>7.3、 年轻代与老年代</h2><h3 id="7-3-1、存储在JVM中的Java对象可以被划分为两类："><a href="#7-3-1、存储在JVM中的Java对象可以被划分为两类：" class="headerlink" title="7.3.1、存储在JVM中的Java对象可以被划分为两类："></a>7.3.1、存储在JVM中的Java对象可以被划分为两类：</h3><ul>
<li>一类是生命周期较短的<strong>瞬时对象</strong>，这类对象的创建和消亡都非常迅速</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</li>
<li>Java堆区进一步细分的话，可以划分为<strong>年轻代（YoungGen）</strong>和<strong>老年代（OldGen）</strong></li>
<li>其中年轻代又可以划分为<strong>Eden空间</strong>、<strong>Survivor0空间</strong>和<strong>survivor1</strong>空间（有时也叫做<strong>from</strong>区、<strong>to</strong>区）<img src="/JVM%E5%9F%BA%E7%A1%80/kuangstudycc240f6d-cfdb-439b-b9c3-e58b6ae94b22.png" class>

</li>
</ul>
<h3 id="7-3-2、配置新生代与老年代在堆结构的占比-默认1-2-。"><a href="#7-3-2、配置新生代与老年代在堆结构的占比-默认1-2-。" class="headerlink" title="7.3.2、配置新生代与老年代在堆结构的占比(默认1:2)。"></a>7.3.2、配置新生代与老年代在堆结构的占比(默认1:2)。</h3><ul>
<li><p>默认<strong>-XX: NewRatio=2</strong>,表示新生代占1,<strong>老年代占2,</strong>新生代占整个堆的1/3</p>
</li>
<li><p>可以修改<strong>-XX: NewRatio=4</strong>,表示新生代占1,<strong>老年代占4,</strong>新生代占整个堆的1/5</p>
</li>
<li><p>-XX:-UseAdaptivesizepoli 关闭自适应的内存分配策略</p>
</li>
<li><p>在 Hotspot中,Eden空间和另外两个 Survivor空间缺省所占的比例是<strong>8:1:1</strong></p>
</li>
<li><p>当然开发人员可以通过选项“-xx: Survivorratio”调整这个空间比例。XX: SurvivorRatio=8</p>
</li>
<li><p><strong>几乎所有</strong>的Java对象都是在Eden区被new出来的</p>
</li>
<li><p>绝大部分的Java对象的销毁都在新生代进行了</p>
<ul>
<li>IBM公司的专门研究表明,新生代中80%的对象都是“朝生夕死”的</li>
</ul>
</li>
<li><p>可以使用选项〃</p>
<p>-Xmn    设置新生代最大内存大小</p>
<ul>
<li>这个参数一般使用默认值就可以了</li>
</ul>
</li>
</ul>
<h2 id="7-4、-图解对象分配过程"><a href="#7-4、-图解对象分配过程" class="headerlink" title="7.4、 图解对象分配过程"></a>7.4、 图解对象分配过程</h2><p>为新对象分配内存是一件非 常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ol>
<li><p>new的对象先放伊甸园区。此区有大小限制。</p>
</li>
<li><p>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p>
</li>
<li><p>然后将伊甸园中的剩余对象移动到幸存者0区。</p>
</li>
<li><p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</p>
</li>
<li><p>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p>
</li>
<li><p>啥时候能去养老区呢?可以设置次数。</p>
<p>默认是15次</p>
<ul>
<li>可以设置参数: -XX:MaxTenuringThreshold=<N> 进行设置。</N></li>
</ul>
</li>
</ol>




<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><ul>
<li>针对幸存者s0,s1区的总结：<strong>复制之后有交换</strong>，<strong>谁空谁是to</strong></li>
<li>关于垃圾回收：<strong>频繁</strong>在新生区收集，<strong>很少</strong>在养老区收集，<strong>几乎不在</strong>永久区/元空间收集。</li>
</ul>


<h2 id="7-5、-Minor-GC、Major-GC、Full-GC"><a href="#7-5、-Minor-GC、Major-GC、Full-GC" class="headerlink" title="7.5、 Minor GC、Major GC、Full GC"></a>7.5、 Minor GC、Major GC、Full GC</h2><p>JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代;方法区)区域一起回收的，<strong>大部分时候回收的都是指新生代</strong>。<br>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型:一 种是部分收集(Partial GC)，一种是整堆收集(Full GC)</p>
<ol>
<li><p>部分收集:不是完整收集整个Java堆的垃圾收集。其中又分为:</p>
<ul>
<li><p>新生代收集(<strong>Minor GC</strong> / Young GC) :只是新生代(Eden\Se,S1)的垃圾收集</p>
</li>
<li><p>老年代收集(MajorGC/ OldGC):只是老年代的垃圾收集。</p>
<ul>
<li>目前，只有<strong>CMS GC</strong>会有<strong>单独收集老年代</strong>的行为。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>
</ul>
<ol start="2">
<li><p>混合收集(Mixed GC):收集整个新生代以及部分老年代的垃圾收集。</p>
<ul>
<li>目前，只有<strong>G1 GC</strong>会有这种行为</li>
</ul>
</li>
<li><p>整堆收集(Fu11 GC):<strong>收集整个java堆和方法区</strong>的垃圾收集。</p>
</li>
</ol>
<h2 id="最简单的分代式GC策略的触发条件"><a href="#最简单的分代式GC策略的触发条件" class="headerlink" title="最简单的分代式GC策略的触发条件"></a>最简单的分代式GC策略的触发条件</h2><p><strong>年轻代GC(Minor GC)触发机制</strong>:</p>
<ul>
<li>当年轻代空间不足时， 就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor满不会引发GC（<strong>要么晋升，要么等待下一次Eden满进行GC</strong>）。(每次 Minor GC会清理年轻代的内存。)</li>
<li>因为<strong>Java对象大多都具备朝生夕灭</strong>的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>
<li>Minor GC会引发STW， 暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>
</ul>
<p>threshold = 阈值默认为15</p>


<p><strong>老年代GC (Major GC/Fu11 GC)触发机制</strong>:</p>
<ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Fu1l GC”发生了。</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC (但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程)<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</li>
<li>如果Major GC后，内存还不足，就报OOM了。</li>
</ul>
<p><strong>Full GC触发机制</strong>:<br>触发Full GC执行的情况有如下五种:</p>
<ol>
<li>调用System. gc()时，系统建议执行Fu11 GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足，</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、survivor space日(From Space) 区向survivor space1 (To Space)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小.<br>说明: full gc是开发或调优中尽量要避免的。这样暂停时间会短一些。</li>
</ol>
<h2 id="7-6、-堆空间分代思想"><a href="#7-6、-堆空间分代思想" class="headerlink" title="7.6、 堆空间分代思想"></a>7.6、 堆空间分代思想</h2><p><strong>为什么需要把Java堆分代?不分代就不能正常工作了吗?</strong><br>其实不分代完全可以，分代的唯一理由就是<strong>优化Gc性能</strong>。如果没有分代，那所有的对象都在一块，就如同把-一个学校的人都关在一-个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>


<h2 id="7-7、-内存分配策略"><a href="#7-7、-内存分配策略" class="headerlink" title="7.7、 内存分配策略"></a>7.7、 内存分配策略</h2><p>如果对象在Eden出生并经过第一次MinorGC 后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对 象年龄设为1。对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁， 当它的年龄增加到一定程度(默认为15岁，其实每个JVM、每个GC都有所不同)时，就会被晋升到老年代中。<br>对象晋升老年代的年龄阈值，可以通过选项<code>-XX:MaxTenuringThreshold</code>来设置。</p>
<p>针对不同年龄段的对象分配原则如下所示:</p>
<ul>
<li>优先分配到Eden</li>
<li>大对象直接分配到老年代<ul>
<li><strong>尽量避免程序中出现过多的大对象</strong></li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果Survivor 区中<strong>相同年龄的所有对象大小的总和大于Survivor空间的一半</strong>，<strong>年龄大于或等于该年龄的对象</strong>可以直接进入老年代，无须等到MaxTenuri ngThreshold中要求的年龄。</li>
</ul>
</li>
<li>空间分配担保（Eden和幸存者区放不下直接放到老年区）<ul>
<li>-XX: HandlePromotionFailure</li>
</ul>
</li>
</ul>
<h2 id="7-8、-为对象分配内存-TLAB"><a href="#7-8、-为对象分配内存-TLAB" class="headerlink" title="7.8、 为对象分配内存: TLAB"></a>7.8、 为对象分配内存: TLAB</h2><p>为什么有TLAB ( Thread Local Allocation Buffer ) ?</p>
<ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是<strong>线程不安全的</strong></li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<p>什么是TLAB ?</p>
<ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域</strong>，它包含在Eden空间内。</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li>
<li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ul>
<p>TLAB再说明</p>
<ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</li>
<li>在程序中，开发人员可以通过选项<code>-XX:TLAB</code>设置是否开启TLAB空间。</li>
<li>默认情况下，TLAB空间的内存非常小，<strong>仅占有整个Eden空间的1%</strong>，当然我们可以通过选项<code>-XX:TLABWasteTargetPercent</code>设置TLAB空间所占用Eden空间的百分比大小。</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用<strong>加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配内存。</li>
</ul>


<h2 id="7-9、-小结堆空间的参数设置"><a href="#7-9、-小结堆空间的参数设置" class="headerlink" title="7. 9、 小结堆空间的参数设置"></a>7. 9、 小结堆空间的参数设置</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">Oracle官网</a></p>
<ul>
<li><p><code>-XX:+PrintFlagsInitial</code> :查看所有的参数的默认初始值</p>
</li>
<li><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintFlagsFinal</code></pre>
<p>:查看所有的参数的最终值(可能会存在修改,不再是初始值)</p>
<ul>
<li>具体查看某个参数的指令: <code>jps</code>: 查看当前运行中的进程 <code>jinfo -flag 参数名 进程id</code></li>
</ul>
</li>
<li><p><code>-Xms:初始堆空间内存</code>( 默认为物理内存的1/64)</p>
</li>
<li><p><code>-Xmx:最大堆空间内存</code>(默认为物理内存的1/4)</p>
</li>
<li><p><code>-Xmn:设置新生代的大小</code>。(初始值及最大值)</p>
</li>
<li><p><code>-XX:NewRatio</code>：配置新生代与老年代在堆结构的占比</p>
</li>
<li><p><code>-XX:SurvivorRatio</code>:设置新生代中Eden和sO/S1空间的比例</p>
</li>
<li><p><code>-XX:MaxTenuringThreshold</code>:设置新生代垃圾的最大年龄</p>
</li>
<li><p><code>-XX:+PrintGCDetails</code>:输出详细的GC处理日志</p>
</li>
<li><p>打印gc简要信息:1.<code>-XX:+PrintGC</code> 2.<code>-verbose:gc</code></p>
</li>
<li><p><code>-XX:HandlePromotionFailure</code>:是否设置空间分配担保</p>
</li>
</ul>
<h2 id="7-10、-堆是分配对象的唯一选择吗"><a href="#7-10、-堆是分配对象的唯一选择吗" class="headerlink" title="7.10、 堆是分配对象的唯一选择吗"></a>7.10、 堆是分配对象的唯一选择吗</h2><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述:随着JIT编译期的发展与逃逸分析技术逐渐成熟，<strong>栈上分配</strong>、<strong>标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析(Escape Analysis) 后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于openJDK深度定制的TaoBaoVM，其中创新的GCIH (GCinvisible heap) 技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
<ul>
<li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li>
<li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li>
<li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li>
<li>逃逸分析的基本行为就是分析对象动态作用域:<ul>
<li>当一个对象在方法中被定义后，<strong>对象只在方法内部使用</strong>，则认为<strong>没有发生逃逸</strong>。</li>
<li>当一个对象在方法中被定义后，它<strong>被外部方法所引用</strong>，则认为<strong>发生逃逸</strong>。例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
</ul>
<p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。</p>
<p><strong>结论:</strong>开发中能使用局部变量的，就不要使用在方法外定义。</p>
<h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><h2 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h2><ol>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所</li>
<li>使用的锁对象<strong>是否只能够被一个线程访问而没有被发布到其他线程</strong>。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫<strong>同步省略</strong>，也叫<strong>锁消除</strong>。</li>
</ol>
<h2 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h2><ol>
<li><strong>标量</strong>(Scalar)是指一个<strong>无法再分解成更小的数据</strong>的数据。Java中的原始数据类型就是标量</li>
<li>相对的，那些还<strong>可以分解</strong>的数据叫做<strong>聚合量</strong>(Aggregate) ，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li>
<li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是<strong>标量替换</strong>。</li>
<li>标量替换参数设置:<ul>
<li>参数<code>-XX: +EliminateAllocations</code>:开启了标量替换(默认打开)，允许将对象打散分配在栈上</li>
</ul>
</li>
</ol>
<p><strong>小结</strong></p>
<ol>
<li>年轻代是对象的诞生、成长、消亡的区域，-一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</li>
<li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB_上;如果对象较大，JVM会试图直接分配在Eden其他位置上;如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li>
<li>当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者Ful1GC。- .般的，MinorGC 的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</li>
</ol>
<h1 id="8、栈、堆、方法区的交互关系"><a href="#8、栈、堆、方法区的交互关系" class="headerlink" title="8、栈、堆、方法区的交互关系"></a>8、栈、堆、方法区的交互关系</h1>{%asset_img kuangstudyba84ddc9-7949-4bf4-bc0d-3a0a4e9c44ea.png%}
{%asset_img kuangstudyc62aa589-9465-4866-bf1b-c2c8fd897974.jpg%}
{%asset_img kuangstudyb8a39844-e561-4e07-bff9-7170d0e45538.jpg%}

<h2 id="8-1、方法区的理解"><a href="#8-1、方法区的理解" class="headerlink" title="8.1、方法区的理解"></a>8.1、方法区的理解</h2><h3 id="8-1-1、方法区在那儿？"><a href="#8-1-1、方法区在那儿？" class="headerlink" title="8.1.1、方法区在那儿？"></a>8.1.1、方法区在那儿？</h3><p>《Java虚拟机规范》中明确说明： “尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non—Heap （非堆）， 目的就是要和堆分开。<br>所以，<strong>方法区看作是一块独立于Java堆的内存空间</strong>。</p>
<h3 id="8-1-2、方法区的基本理解"><a href="#8-1-2、方法区的基本理解" class="headerlink" title="8.1.2、方法区的基本理解"></a>8.1.2、方法区的基本理解</h3><ol>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误： java.lang .OutofMemoryError：</li>
<li>PermGen space或者java. lang.OutofMemoryError: Metaspace 关闭JVM就会释放这个区域的内存。</li>
</ol>
{%asset_img kuangstudy99ac8cb8-20cb-4c0a-99c6-aa373dac022d.png%}
{%asset_img kuangstudy742d9bfb-6405-4ef9-b7fc-9e1e7705e073.png%}

<ol>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永夕代最大的区别在于：元空间不在虚拟机设置的内存中，而是<strong>使用本地内存</strong>。</li>
<li>永久代、元空间二者并不只是名字变了，内部结构也调整了。</li>
<li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。</li>
</ol>
<h2 id="8-2、设置方法区大小与OOM"><a href="#8-2、设置方法区大小与OOM" class="headerlink" title="8.2、设置方法区大小与OOM"></a>8.2、设置方法区大小与OOM</h2><h3 id="8-2-1、JDK7"><a href="#8-2-1、JDK7" class="headerlink" title="8.2.1、JDK7"></a>8.2.1、JDK7</h3><p>方法区的大小不必是固定的， jvm可以根据应用的需要动态调整。</p>
<ol>
<li>通过—xx： Permsize来设置永久代初始分配空间。默认值是20.75M</li>
<li>xx： MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M， 64位机器模式是82M</li>
<li>当JVM加载的类信息容量超过了这个值，会报异常outofMemoryError ： PermGenspace 。</li>
</ol>
<h3 id="8-2-2、JDK8"><a href="#8-2-2、JDK8" class="headerlink" title="8.2.2、JDK8"></a>8.2.2、JDK8</h3><ol>
<li>元数据区大小可以使用参数<code>-XX：Metaspacesize</code>和<code>-XX：MaxMetaspacesize</code>指定，替代上述原有的两个参数。</li>
<li>默认值依赖于平台.windows下,<code>-XX:Metaspacesize</code>是21M, <code>-XX:MaxMetaspacesize</code>的值是-1，即没有限制。</li>
<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>outOfMemoryError： Metaspace</code> <code>-XX：Metaspacesize</code>：<strong>设置初始的元空间大小</strong>。对于一个64位的服务器端JVM来说，其默认的—Xx： MetaspaceSize值为21MB.这就是初始的高水位线，一旦触及这个水位线， Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于Gc后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspacesize时，适当提高该值。如果释放空间过多，则适当降低该值。</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到FULL GC多次调用。为了避免频繁地GC ，建议将<code>-XX：Metaspacesize</code>设置为一个相对较高的值。</li>
</ol>
<h2 id="8-3、方法区的内部结构"><a href="#8-3、方法区的内部结构" class="headerlink" title="8.3、方法区的内部结构"></a>8.3、方法区的内部结构</h2>{%asset_img kuangstudy635ebea5-ee38-4e8d-900e-4925d56d2cb8.png%}

<h3 id="8-3-1、方法区存储什么"><a href="#8-3-1、方法区存储什么" class="headerlink" title="8.3.1、方法区存储什么"></a>8.3.1、方法区存储什么</h3><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：<br>它用于存储已被虚拟机加载的<strong>类型信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码缓存</strong>等。</p>
{%asset_img kuangstudy3f748773-3b32-4000-ab13-9728c32bc6e9.png%}

<p>小结：<br>常量池，可以看做是一张表，虚拟机指令根据这张<strong>常量表找到要执行的类名、方法名、参数类型、字面量</strong>等类型。</p>
<h3 id="8-3-2、运行时常量池"><a href="#8-3-2、运行时常量池" class="headerlink" title="8.3.2、运行时常量池"></a>8.3.2、运行时常量池</h3><ol>
<li>运行时常量池（Runtime Constant Pool）是<strong>方法区的一部分</strong>。</li>
<li>常量池表（Constant Pool Table）是<strong>Class文件的一部分</strong>，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。<ul>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。string.intern ()</li>
</ul>
</li>
<li>运行时常量池类似于传统编程语言中的符号表（symbol table） ，但是它所包含的数据却比符号表要更加丰富一些</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</li>
</ol>
<h2 id="8-4、方法区的演进细节"><a href="#8-4、方法区的演进细节" class="headerlink" title="8.4、方法区的演进细节"></a>8.4、方法区的演进细节</h2>{%asset_img kuangstudyd1b2dd92-478d-4397-bd7a-f941b2f8dfeb.png%}
{%asset_img kuangstudy28b6b1ab-8c85-49d1-ba6c-fdf5d52dfdaa.png%}

<h2 id="8-5、永久代为什么被元空间代替"><a href="#8-5、永久代为什么被元空间代替" class="headerlink" title="8.5、永久代为什么被元空间代替"></a>8.5、永久代为什么被元空间代替</h2><ol>
<li>随着Java8的到来， HotSpot vM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间( Metaspace）</li>
<li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</li>
<li>这项改动是很有必要的，原因有：<ul>
<li>永久代设置空间大小是很难确定的。<ul>
<li>如果动态加载类过多，容易产生Perm区的00M。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。”Exception in thread ‘dubbo client x.x connector’ java.lang.OutOMemoryError: PermGen space而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</li>
</ul>
</li>
<li>永久代进行调优是很困难的。</li>
</ul>
</li>
</ol>
<h2 id="8-6、方法区的垃圾回收"><a href="#8-6、方法区的垃圾回收" class="headerlink" title="8.6、方法区的垃圾回收"></a>8.6、方法区的垃圾回收</h2><h3 id="8-6-1、StringTable为什么要调整？"><a href="#8-6-1、StringTable为什么要调整？" class="headerlink" title="8.6.1、StringTable为什么要调整？"></a>8.6.1、StringTable为什么要调整？</h3><ol>
<li>jdk7中将stringmable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。</li>
<li>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。<strong>放到堆里，能及时回收内存</strong>。</li>
</ol>
<h3 id="8-6-2、类的回收"><a href="#8-6-2、类的回收" class="headerlink" title="8.6.2、类的回收"></a>8.6.2、类的回收</h3><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:</p>
<ol>
<li><p><strong>该类所有的实例</strong>都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p>
</li>
<li><p><strong>加载该类的类加载器</strong>已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p>
</li>
<li><p><strong>该类对应的java.lang.Class对象</strong>没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ol>
<p>Java虛拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象- -样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code>以及<code>-XX:+TraceClass-Loading</code>、<code>-XX:+TraceClassUnLoading</code> 查看类加载和卸载信息</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及osGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h2 id="8-7、总结"><a href="#8-7、总结" class="headerlink" title="8.7、总结"></a>8.7、总结</h2>{%asset_img 43586a328cb2.jpg%}

<h1 id="9、垃圾回收概述"><a href="#9、垃圾回收概述" class="headerlink" title="9、垃圾回收概述"></a>9、垃圾回收概述</h1><h2 id="9-1、什么是垃圾-Garbage-呢"><a href="#9-1、什么是垃圾-Garbage-呢" class="headerlink" title="9.1、什么是垃圾( Garbage) 呢?"></a>9.1、什么是垃圾( Garbage) 呢?</h2><ol>
<li>垃圾是指在<strong>运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li>
<li>外文: An object is considered garbage when it can no longer be reached from any pointer in the running program.</li>
<li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</li>
</ol>
<h2 id="9-1-2、为什么需要GC"><a href="#9-1-2、为什么需要GC" class="headerlink" title="9.1.2、为什么需要GC"></a>9.1.2、为什么需要GC</h2><ol>
<li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li>
<li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便<strong>JVM将整理出的内存分配给新的对象</strong>。</li>
<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
</ol>
<h3 id="9-1-3、早期垃圾回收"><a href="#9-1-3、早期垃圾回收" class="headerlink" title="9.1.3、早期垃圾回收"></a>9.1.3、早期垃圾回收</h3><p>在早期的C/C+ +时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码:</p>
<pre class=" language-java"><code class="language-java">MibBridge <span class="token operator">*</span>pBridge <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">cmBaseGroupBridge</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//如果注册失败，使用Delete释放该对象所占内存区域if (pBridge->Register (kDestroy) != NO_ ERROR)delete pBridge;</span></code></pre>
<p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p>
<h3 id="9-1-4、Java垃圾回收机制"><a href="#9-1-4、Java垃圾回收机制" class="headerlink" title="9.1.4、Java垃圾回收机制"></a>9.1.4、Java垃圾回收机制</h3>

<ul>
<li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险<ul>
<li>没有垃圾回收器，java也会和cpp-样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li>
</ul>
</li>
<li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li>
<li>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。<ul>
<li>其中，Java堆是垃圾收集器的工作重点。</li>
</ul>
</li>
<li>从次数上讲:<ul>
<li><strong>频繁收集Young区</strong></li>
<li><strong>较少收集Old区</strong></li>
<li><strong>基本不动Perm区(或元空间)</strong></li>
</ul>
</li>
</ul>
<h2 id="9-2、缺点"><a href="#9-2、缺点" class="headerlink" title="9.2、缺点"></a>9.2、缺点</h2><ol>
<li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于自动”，那么这将会是一一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</strong></li>
<li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时,快速地根据错误异常日志定位问题和解决问题。</li>
<li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施<strong>必要的监控和调节</strong>。</li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Mr-lee</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://mr-lee-mq.github.io/JVM%E5%9F%BA%E7%A1%80/">https://mr-lee-mq.github.io/JVM%E5%9F%BA%E7%A1%80/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Mr-lee</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Java%E8%BF%9B%E9%98%B6/">
                                    <span class="chip bg-color">Java进阶</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/SpringBoot/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="Spring Boot">
                        
                        <span class="card-title">Spring Boot</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1、Spring Boot 入门
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-03-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%90%8E%E7%AB%AF/" class="post-category">
                                    后端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/">
                        <span class="chip bg-color">后端框架</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/SSM%E6%95%B4%E5%90%88/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="SSM整合">
                        
                        <span class="card-title">SSM整合</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            SSM(整合)
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-03-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%90%8E%E7%AB%AF/" class="post-category">
                                    后端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/">
                        <span class="chip bg-color">后端框架</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2083953023"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2020-2022</span>
            
            <span id="year">2020</span>
            <a href="/about" target="_blank">Mr-lee</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "4";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Mr-lee-MQ/Mr-lee-MQ.github.io" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2285051311@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2285051311" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2285051311" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    
    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
	
	
	

</body>

</html>
